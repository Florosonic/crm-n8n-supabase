[
  {
    "filename": "close_deal.sql",
    "content": "CREATE OR REPLACE FUNCTION public.close_deal(p_deal_id uuid, p_status character varying, p_close_reason text DEFAULT NULL::text)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_old_status VARCHAR(20);\r\n    v_old_stage INTEGER;\r\n    v_company_name TEXT;\r\n    v_product_name TEXT;\r\nBEGIN\r\n    -- Проверяем валидность статуса\r\n    IF p_status NOT IN ('won', 'lost') THEN\r\n        RAISE EXCEPTION 'Статус должен быть won или lost';\r\n    END IF;\r\n    \r\n    -- Получаем текущую информацию о сделке\r\n    SELECT d.status, d.stage, c.name, d.product_name\r\n    INTO v_old_status, v_old_stage, v_company_name, v_product_name\r\n    FROM deals d\r\n    JOIN companies c ON c.id = d.company_id\r\n    WHERE d.id = p_deal_id;\r\n    \r\n    -- Проверяем существование сделки\r\n    IF NOT FOUND THEN\r\n        RAISE EXCEPTION 'Сделка не найдена: %', p_deal_id;\r\n    END IF;\r\n    \r\n    -- Проверяем, не закрыта ли уже сделка\r\n    IF v_old_status != 'open' THEN\r\n        RAISE EXCEPTION 'Сделка уже закрыта со статусом: %', v_old_status;\r\n    END IF;\r\n    \r\n    -- Обновляем сделку\r\n    UPDATE deals\r\n    SET \r\n        status = p_status,\r\n        closed_at = NOW(),\r\n        notes = CASE \r\n            WHEN p_close_reason IS NOT NULL THEN \r\n                COALESCE(notes || E'\\n---\\n' || TO_CHAR(NOW(), 'DD.MM.YYYY HH24:MI') || \r\n                E'\\nСделка закрыта (' || p_status || '): ' || p_close_reason, p_close_reason)\r\n            ELSE notes\r\n        END,\r\n        updated_at = NOW()\r\n    WHERE id = p_deal_id;\r\n    \r\n    -- Закрываем все активные пинги для этой сделки\r\n    UPDATE pings\r\n    SET is_completed = TRUE, completed_at = NOW()\r\n    WHERE deal_id = p_deal_id AND is_completed = FALSE;\r\n    \r\n    RETURN jsonb_build_object(\r\n        'success', TRUE,\r\n        'deal_id', p_deal_id,\r\n        'status', p_status,\r\n        'company_name', v_company_name,\r\n        'product_name', v_product_name,\r\n        'old_stage', v_old_stage,\r\n        'closed_at', NOW()\r\n    );\r\nEXCEPTION\r\n    WHEN OTHERS THEN\r\n        RETURN jsonb_build_object(\r\n            'success', FALSE,\r\n            'error', SQLERRM\r\n        );\r\nEND;\r\n$function$\n"
  },
  {
    "filename": "get_deals_statistics.sql",
    "content": "CREATE OR REPLACE FUNCTION public.get_deals_statistics()\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_total INTEGER;\r\n    v_open INTEGER;\r\n    v_won INTEGER;\r\n    v_lost INTEGER;\r\n    v_won_revenue NUMERIC;\r\nBEGIN\r\n    SELECT COUNT(*) INTO v_total FROM deals;\r\n    SELECT COUNT(*) INTO v_open FROM deals WHERE status = 'open';\r\n    SELECT COUNT(*) INTO v_won FROM deals WHERE status = 'won';\r\n    SELECT COUNT(*) INTO v_lost FROM deals WHERE status = 'lost';\r\n    SELECT COALESCE(SUM(price), 0) INTO v_won_revenue FROM deals WHERE status = 'won';\r\n    \r\n    RETURN jsonb_build_object(\r\n        'total_deals', v_total,\r\n        'open_deals', v_open,\r\n        'won_deals', v_won,\r\n        'lost_deals', v_lost,\r\n        'win_rate', CASE \r\n            WHEN (v_won + v_lost) > 0 THEN \r\n                ROUND((v_won::NUMERIC / (v_won + v_lost)) * 100, 2)\r\n            ELSE 0 \r\n        END,\r\n        'total_revenue', v_won_revenue\r\n    );\r\nEND;\r\n$function$\n"
  },
  {
    "filename": "get_today_pings.sql",
    "content": "CREATE OR REPLACE FUNCTION public.get_today_pings()\n RETURNS TABLE(ping_id uuid, ping_date date, action text, company_name text, contact_name text, contact_email text, product_name text, stage integer, stage_name text, last_notes text)\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    RETURN QUERY\r\n    SELECT \r\n        p.id as ping_id,\r\n        p.ping_date,\r\n        p.action,\r\n        c.name as company_name,\r\n        COALESCE(cnt.first_name || ' ' || cnt.last_name, 'Контакт не указан') as contact_name,\r\n        cnt.email as contact_email,\r\n        d.product_name,\r\n        d.stage,\r\n        ps.name as stage_name,\r\n        d.notes as last_notes\r\n    FROM pings p\r\n    JOIN deals d ON d.id = p.deal_id\r\n    JOIN companies c ON c.id = d.company_id\r\n    LEFT JOIN contacts cnt ON cnt.id = d.contact_id\r\n    JOIN pipeline_stages ps ON ps.id = d.stage\r\n    WHERE p.ping_date <= CURRENT_DATE\r\n      AND p.is_completed = FALSE\r\n    ORDER BY p.ping_date, c.name;\r\nEND;\r\n$function$\n"
  },
  {
    "filename": "get_weekly_summary.sql",
    "content": "CREATE OR REPLACE FUNCTION public.get_weekly_summary()\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_overdue_pings JSONB;\r\n    v_stuck_deals JSONB;\r\n    v_pipeline_stats JSONB;\r\nBEGIN\r\n    -- Просроченные пинги\r\n    SELECT jsonb_agg(row_to_json(t))\r\n    INTO v_overdue_pings\r\n    FROM (\r\n        SELECT \r\n            c.name as company,\r\n            d.product_name as product,\r\n            p.ping_date,\r\n            p.action,\r\n            (CURRENT_DATE - p.ping_date) as days_overdue\r\n        FROM pings p\r\n        JOIN deals d ON d.id = p.deal_id\r\n        JOIN companies c ON c.id = d.company_id\r\n        WHERE p.ping_date < CURRENT_DATE\r\n          AND p.is_completed = FALSE\r\n        ORDER BY p.ping_date\r\n    ) t;\r\n    \r\n    -- Застрявшие сделки (без движения > 2 недель)\r\n    SELECT jsonb_agg(row_to_json(t))\r\n    INTO v_stuck_deals\r\n    FROM (\r\n        SELECT \r\n            c.name as company,\r\n            d.product_name as product,\r\n            ps.name as stage,\r\n            d.updated_at::DATE as last_update,\r\n            (CURRENT_DATE - d.updated_at::DATE) as days_inactive\r\n        FROM deals d\r\n        JOIN companies c ON c.id = d.company_id\r\n        JOIN pipeline_stages ps ON ps.id = d.stage\r\n        WHERE d.closed_at IS NULL\r\n          AND d.updated_at < CURRENT_DATE - INTERVAL '14 days'\r\n        ORDER BY d.updated_at\r\n    ) t;\r\n    \r\n    -- Статистика по воронке\r\n    SELECT jsonb_agg(row_to_json(t))\r\n    INTO v_pipeline_stats\r\n    FROM (\r\n        SELECT \r\n            ps.id as stage,\r\n            ps.name as stage_name,\r\n            COUNT(d.id) as deal_count,\r\n            COALESCE(SUM(d.price), 0) as total_value\r\n        FROM pipeline_stages ps\r\n        LEFT JOIN deals d ON d.stage = ps.id AND d.closed_at IS NULL\r\n        GROUP BY ps.id, ps.name\r\n        ORDER BY ps.id\r\n    ) t;\r\n    \r\n    RETURN jsonb_build_object(\r\n        'overdue_pings', COALESCE(v_overdue_pings, '[]'::JSONB),\r\n        'stuck_deals', COALESCE(v_stuck_deals, '[]'::JSONB),\r\n        'pipeline_stats', COALESCE(v_pipeline_stats, '[]'::JSONB),\r\n        'generated_at', NOW()\r\n    );\r\nEND;\r\n$function$\n"
  },
  {
    "filename": "manage_pings.sql",
    "content": "CREATE OR REPLACE FUNCTION public.manage_pings(p_deal_id uuid, p_new_stage integer, p_stage_changed boolean, p_manual_ping_date date, p_sample_shipment_date date)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_ping_interval INTERVAL;\r\n    v_ping_type TEXT;\r\n    v_ping_action TEXT;\r\n    v_ping_date DATE;\r\n    v_pings_created INTEGER := 0;\r\n    v_pings_closed INTEGER := 0;\r\n    v_warnings TEXT[] := ARRAY[]::TEXT[];\r\n    v_next_ping_date DATE := NULL;\r\nBEGIN\r\n    IF p_manual_ping_date IS NOT NULL THEN\r\n        UPDATE pings\r\n        SET is_completed = TRUE,\r\n            completed_at = NOW(),\r\n            notes = 'Заменен ручным пингом'\r\n        WHERE deal_id = p_deal_id\r\n          AND type IN ('auto', 'manual', 'recurring')\r\n          AND is_completed = FALSE;\r\n        \r\n        GET DIAGNOSTICS v_pings_closed = ROW_COUNT;\r\n        \r\n        INSERT INTO pings (deal_id, ping_date, type, action)\r\n        VALUES (p_deal_id, p_manual_ping_date, 'manual', 'Выполнить запланированное действие');\r\n        \r\n        v_pings_created := 1;\r\n        v_next_ping_date := p_manual_ping_date;\r\n        \r\n        RETURN jsonb_build_object(\r\n            'pings_created', v_pings_created,\r\n            'pings_closed', v_pings_closed,\r\n            'warnings', v_warnings,\r\n            'next_ping_date', v_next_ping_date\r\n        );\r\n    END IF;\r\n    \r\n    IF p_stage_changed THEN\r\n        UPDATE pings\r\n        SET is_completed = TRUE,\r\n            completed_at = NOW(),\r\n            notes = 'Закрыто при смене этапа'\r\n        WHERE deal_id = p_deal_id\r\n          AND type IN ('auto', 'recurring')\r\n          AND is_completed = FALSE;\r\n        \r\n        GET DIAGNOSTICS v_pings_closed = ROW_COUNT;\r\n        \r\n        SELECT ping_interval, ping_type, ping_action\r\n        INTO v_ping_interval, v_ping_type, v_ping_action\r\n        FROM pipeline_stages\r\n        WHERE id = p_new_stage;\r\n        \r\n        IF p_new_stage IN (3, 4, 5) THEN\r\n            IF p_sample_shipment_date IS NOT NULL THEN\r\n                IF p_new_stage = 3 THEN\r\n                    v_ping_date := CURRENT_DATE;\r\n                ELSIF p_new_stage = 4 THEN\r\n                    v_ping_date := p_sample_shipment_date + INTERVAL '14 days';\r\n                ELSIF p_new_stage = 5 THEN\r\n                    v_ping_date := p_sample_shipment_date + INTERVAL '30 days';\r\n                END IF;\r\n            ELSE\r\n                v_ping_date := CURRENT_DATE;\r\n                IF p_new_stage = 3 THEN\r\n                    v_ping_action := 'Уточнить дату отгрузки образцов';\r\n                END IF;\r\n                v_warnings := array_append(v_warnings, 'Для этапа ' || p_new_stage || ' рекомендуется указать дату отгрузки');\r\n            END IF;\r\n        ELSE\r\n            v_ping_date := CURRENT_DATE + v_ping_interval;\r\n        END IF;\r\n        \r\n        -- Проверка: если пинг в прошлом, ставим через 14 дней от сегодня\r\n        IF v_ping_date < CURRENT_DATE THEN\r\n            v_ping_date := CURRENT_DATE + INTERVAL '14 days';\r\n        END IF;\r\n        \r\n        IF v_ping_type = 'recurring' THEN\r\n            INSERT INTO pings (deal_id, ping_date, type, action)\r\n            VALUES (p_deal_id, v_ping_date, 'recurring', v_ping_action);\r\n        ELSE\r\n            INSERT INTO pings (deal_id, ping_date, type, action)\r\n            VALUES (p_deal_id, v_ping_date, 'auto', v_ping_action);\r\n        END IF;\r\n        \r\n        v_pings_created := v_pings_created + 1;\r\n        v_next_ping_date := v_ping_date;\r\n    END IF;\r\n    \r\n    UPDATE pings\r\n    SET is_completed = TRUE,\r\n        completed_at = NOW(),\r\n        notes = 'Автоматически закрыто при обновлении сделки'\r\n    WHERE deal_id = p_deal_id\r\n      AND ping_date < CURRENT_DATE\r\n      AND is_completed = FALSE;\r\n    \r\n    RETURN jsonb_build_object(\r\n        'pings_created', v_pings_created,\r\n        'pings_closed', v_pings_closed,\r\n        'warnings', v_warnings,\r\n        'next_ping_date', v_next_ping_date\r\n    );\r\nEND;\r\n$function$\n"
  },
  {
    "filename": "mark_ping_completed.sql",
    "content": "CREATE OR REPLACE FUNCTION public.mark_ping_completed(p_ping_id uuid, p_notes text DEFAULT NULL::text)\n RETURNS boolean\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    UPDATE pings\r\n    SET is_completed = TRUE,\r\n        completed_at = NOW(),\r\n        notes = COALESCE(p_notes, 'Выполнено вручную')\r\n    WHERE id = p_ping_id;\r\n    \r\n    RETURN FOUND;\r\nEND;\r\n$function$\n"
  },
  {
    "filename": "process_email.sql",
    "content": "CREATE OR REPLACE FUNCTION public.process_email(p_data jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_company_id UUID;\r\n    v_contact_id UUID;\r\n    v_deal_result JSONB;\r\n    v_ping_result JSONB;\r\n    v_warnings TEXT[] := ARRAY[]::TEXT[];\r\n    v_confidence NUMERIC;\r\nBEGIN\r\n    -- Извлекаем уверенность AI\r\n    v_confidence := COALESCE((p_data->>'confidence')::NUMERIC, 1.0);\r\n    \r\n    -- Если низкая уверенность - добавляем предупреждение\r\n    IF v_confidence < 0.7 THEN\r\n        v_warnings := array_append(v_warnings, \r\n            'Низкая уверенность AI в парсинге: ' || (v_confidence * 100)::INTEGER || '%');\r\n    END IF;\r\n    \r\n    -- НОВОЕ: Проверяем existing_deal_id\r\n    IF (p_data->>'existing_deal_id') IS NOT NULL THEN\r\n        -- Получаем company_id из существующей сделки\r\n        SELECT company_id, contact_id \r\n        INTO v_company_id, v_contact_id\r\n        FROM deals \r\n        WHERE id = (p_data->>'existing_deal_id')::UUID;\r\n        \r\n        -- Обновляем контакт если передан\r\n        IF (p_data->>'contact_email') IS NOT NULL OR \r\n           (p_data->>'contact_first_name') IS NOT NULL OR \r\n           (p_data->>'contact_last_name') IS NOT NULL THEN\r\n            v_contact_id := upsert_contact(\r\n                p_data->>'contact_email',\r\n                p_data->>'contact_first_name',\r\n                p_data->>'contact_last_name',\r\n                p_data->>'contact_phone',\r\n                v_company_id\r\n            );\r\n        END IF;\r\n    ELSE\r\n        -- Старая логика для новых сделок\r\n        -- 1. Обрабатываем компанию\r\n        v_company_id := upsert_company(p_data->>'company_name');\r\n        \r\n        -- 2. Обрабатываем контакт (если указан)\r\n        IF (p_data->>'contact_email') IS NOT NULL OR \r\n           (p_data->>'contact_first_name') IS NOT NULL OR \r\n           (p_data->>'contact_last_name') IS NOT NULL THEN\r\n            v_contact_id := upsert_contact(\r\n                p_data->>'contact_email',\r\n                p_data->>'contact_first_name',\r\n                p_data->>'contact_last_name',\r\n                p_data->>'contact_phone',\r\n                v_company_id\r\n            );\r\n        END IF;\r\n    END IF;\r\n    \r\n    -- 3. Обрабатываем сделку\r\n    v_deal_result := upsert_deal(\r\n        v_company_id,\r\n        v_contact_id,\r\n        p_data->>'product_name',\r\n        p_data->>'product_description',\r\n        (p_data->>'price')::DECIMAL,\r\n        COALESCE((p_data->>'stage')::INTEGER, 1),\r\n        (p_data->>'sample_shipment_date')::DATE,\r\n        p_data->>'notes'\r\n    );\r\n    \r\n    -- 4. Управляем пингами\r\n    v_ping_result := manage_pings(\r\n        (v_deal_result->>'deal_id')::UUID,\r\n        COALESCE((p_data->>'stage')::INTEGER, 1),\r\n        (v_deal_result->>'stage_changed')::BOOLEAN,\r\n        (p_data->>'manual_ping_date')::DATE,\r\n        (p_data->>'sample_shipment_date')::DATE\r\n    );\r\n    \r\n    -- Объединяем предупреждения\r\n    IF jsonb_array_length(v_ping_result->'warnings') > 0 THEN\r\n        v_warnings := v_warnings || ARRAY(\r\n            SELECT jsonb_array_elements_text(v_ping_result->'warnings')\r\n        );\r\n    END IF;\r\n    \r\n    -- Формируем ответ\r\n    RETURN jsonb_build_object(\r\n        'success', TRUE,\r\n        'deal_id', v_deal_result->>'deal_id',\r\n        'company_id', v_company_id,\r\n        'contact_id', v_contact_id,\r\n        'stage', COALESCE((p_data->>'stage')::INTEGER, 1),\r\n        'stage_changed', v_deal_result->>'stage_changed',\r\n        'pings_created', v_ping_result->>'pings_created',\r\n        'pings_closed', v_ping_result->>'pings_closed',\r\n        'has_warnings', (array_length(v_warnings, 1) > 0),\r\n        'warnings', v_warnings,\r\n        'next_ping_date', v_ping_result->>'next_ping_date'  -- НОВОЕ: добавляем дату пинга\r\n    );\r\nEXCEPTION\r\n    WHEN OTHERS THEN\r\n        RETURN jsonb_build_object(\r\n            'success', FALSE,\r\n            'error', SQLERRM,\r\n            'has_warnings', TRUE,\r\n            'warnings', ARRAY['Критическая ошибка: ' || SQLERRM]\r\n        );\r\nEND;\r\n$function$\n"
  },
  {
    "filename": "reopen_deal.sql",
    "content": "CREATE OR REPLACE FUNCTION public.reopen_deal(p_deal_id uuid, p_reason text DEFAULT NULL::text)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_old_status VARCHAR(20);\r\n    v_company_name TEXT;\r\n    v_product_name TEXT;\r\nBEGIN\r\n    -- Получаем текущую информацию о сделке\r\n    SELECT d.status, c.name, d.product_name\r\n    INTO v_old_status, v_company_name, v_product_name\r\n    FROM deals d\r\n    JOIN companies c ON c.id = d.company_id\r\n    WHERE d.id = p_deal_id;\r\n    \r\n    -- Проверяем существование сделки\r\n    IF NOT FOUND THEN\r\n        RAISE EXCEPTION 'Сделка не найдена: %', p_deal_id;\r\n    END IF;\r\n    \r\n    -- Проверяем, закрыта ли сделка\r\n    IF v_old_status = 'open' THEN\r\n        RAISE EXCEPTION 'Сделка уже открыта';\r\n    END IF;\r\n    \r\n    -- Переоткрываем сделку\r\n    UPDATE deals\r\n    SET \r\n        status = 'open',\r\n        closed_at = NULL,\r\n        notes = CASE \r\n            WHEN p_reason IS NOT NULL THEN \r\n                COALESCE(notes || E'\\n---\\n' || TO_CHAR(NOW(), 'DD.MM.YYYY HH24:MI') || \r\n                E'\\nСделка переоткрыта: ' || p_reason, p_reason)\r\n            ELSE notes || E'\\n---\\n' || TO_CHAR(NOW(), 'DD.MM.YYYY HH24:MI') || \r\n                E'\\nСделка переоткрыта'\r\n        END,\r\n        updated_at = NOW()\r\n    WHERE id = p_deal_id;\r\n    \r\n    RETURN jsonb_build_object(\r\n        'success', TRUE,\r\n        'deal_id', p_deal_id,\r\n        'status', 'open',\r\n        'old_status', v_old_status,\r\n        'company_name', v_company_name,\r\n        'product_name', v_product_name\r\n    );\r\nEXCEPTION\r\n    WHEN OTHERS THEN\r\n        RETURN jsonb_build_object(\r\n            'success', FALSE,\r\n            'error', SQLERRM\r\n        );\r\nEND;\r\n$function$\n"
  },
  {
    "filename": "update_updated_at_column.sql",
    "content": "CREATE OR REPLACE FUNCTION public.update_updated_at_column()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    NEW.updated_at = TIMEZONE('utc', NOW());\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "filename": "upsert_company.sql",
    "content": "CREATE OR REPLACE FUNCTION public.upsert_company(p_name text)\n RETURNS uuid\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_normalized_name TEXT;\r\n    v_company_id UUID;\r\nBEGIN\r\n    -- Нормализация названия: убираем ООО, АО, кавычки, лишние пробелы\r\n    v_normalized_name := TRIM(p_name);\r\n    v_normalized_name := REGEXP_REPLACE(v_normalized_name, '^(ООО|ОАО|ЗАО|АО|ИП|ПАО)\\s+', '', 'i');\r\n    v_normalized_name := REGEXP_REPLACE(v_normalized_name, '[«»\"''\"]', '', 'g');\r\n    v_normalized_name := TRIM(v_normalized_name);\r\n    \r\n    -- Проверка на пустое название\r\n    IF v_normalized_name = '' OR v_normalized_name IS NULL THEN\r\n        v_normalized_name := 'Компания ' || TO_CHAR(NOW(), 'DD.MM.YYYY');\r\n    END IF;\r\n    \r\n    -- Поиск существующей компании\r\n    SELECT id INTO v_company_id\r\n    FROM companies\r\n    WHERE LOWER(REGEXP_REPLACE(REGEXP_REPLACE(name, '^(ООО|ОАО|ЗАО|АО|ИП|ПАО)\\s+', '', 'i'), '[«»\"''\"]', '', 'g')) \r\n          = LOWER(v_normalized_name);\r\n    \r\n    -- Если не нашли - создаем новую\r\n    IF v_company_id IS NULL THEN\r\n        INSERT INTO companies (name, notes)\r\n        VALUES (v_normalized_name, 'Создано автоматически из email')\r\n        RETURNING id INTO v_company_id;\r\n    END IF;\r\n    \r\n    RETURN v_company_id;\r\nEND;\r\n$function$\n"
  },
  {
    "filename": "upsert_contact.sql",
    "content": "CREATE OR REPLACE FUNCTION public.upsert_contact(p_email text, p_first_name text, p_last_name text, p_company_id uuid)\n RETURNS uuid\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_contact_id UUID;\r\n    v_normalized_email TEXT;\r\nBEGIN\r\n    -- Нормализация email\r\n    v_normalized_email := LOWER(TRIM(p_email));\r\n    \r\n    -- Сначала ищем по email, если указан\r\n    IF v_normalized_email IS NOT NULL AND v_normalized_email != '' THEN\r\n        SELECT id INTO v_contact_id\r\n        FROM contacts\r\n        WHERE LOWER(email) = v_normalized_email;\r\n        \r\n        -- Если нашли по email - обновляем ФИО и компанию если нужно\r\n        IF v_contact_id IS NOT NULL THEN\r\n            UPDATE contacts\r\n            SET first_name = COALESCE(p_first_name, first_name),\r\n                last_name = COALESCE(p_last_name, last_name),\r\n                company_id = COALESCE(p_company_id, company_id),\r\n                updated_at = NOW()\r\n            WHERE id = v_contact_id;\r\n            RETURN v_contact_id;\r\n        END IF;\r\n    END IF;\r\n    \r\n    -- Если не нашли по email - ищем по ФИО + компания\r\n    IF p_first_name IS NOT NULL OR p_last_name IS NOT NULL THEN\r\n        SELECT id INTO v_contact_id\r\n        FROM contacts\r\n        WHERE company_id = p_company_id\r\n          AND LOWER(COALESCE(first_name, '')) = LOWER(COALESCE(p_first_name, ''))\r\n          AND LOWER(COALESCE(last_name, '')) = LOWER(COALESCE(p_last_name, ''));\r\n        \r\n        -- Если нашли по ФИО - обновляем email\r\n        IF v_contact_id IS NOT NULL THEN\r\n            UPDATE contacts\r\n            SET email = COALESCE(v_normalized_email, email),\r\n                updated_at = NOW()\r\n            WHERE id = v_contact_id;\r\n            RETURN v_contact_id;\r\n        END IF;\r\n    END IF;\r\n    \r\n    -- Если никого не нашли - создаем нового\r\n    INSERT INTO contacts (company_id, email, first_name, last_name)\r\n    VALUES (p_company_id, v_normalized_email, p_first_name, p_last_name)\r\n    RETURNING id INTO v_contact_id;\r\n    \r\n    RETURN v_contact_id;\r\nEND;\r\n$function$\n"
  },
  {
    "filename": "upsert_contact.sql",
    "content": "CREATE OR REPLACE FUNCTION public.upsert_contact(p_email text, p_first_name text, p_last_name text, p_phone text, p_company_id uuid)\n RETURNS uuid\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_contact_id UUID;\r\n    v_normalized_email TEXT;\r\nBEGIN\r\n    -- Нормализация email\r\n    v_normalized_email := LOWER(TRIM(p_email));\r\n    \r\n    -- Сначала ищем по email, если указан\r\n    IF v_normalized_email IS NOT NULL AND v_normalized_email != '' THEN\r\n        SELECT id INTO v_contact_id\r\n        FROM contacts\r\n        WHERE LOWER(email) = v_normalized_email;\r\n        \r\n        -- Если нашли по email - обновляем ФИО и компанию если нужно\r\n        IF v_contact_id IS NOT NULL THEN\r\n            UPDATE contacts\r\n            SET first_name = COALESCE(p_first_name, first_name),\r\n                last_name = COALESCE(p_last_name, last_name),\r\n                phone = COALESCE(p_phone, phone),\r\n                company_id = COALESCE(p_company_id, company_id),\r\n                updated_at = NOW()\r\n            WHERE id = v_contact_id;\r\n            RETURN v_contact_id;\r\n        END IF;\r\n    END IF;\r\n    \r\n    -- Если не нашли по email - ищем по ФИО + компания\r\n    IF p_first_name IS NOT NULL OR p_last_name IS NOT NULL THEN\r\n        SELECT id INTO v_contact_id\r\n        FROM contacts\r\n        WHERE company_id = p_company_id\r\n          AND LOWER(COALESCE(first_name, '')) = LOWER(COALESCE(p_first_name, ''))\r\n          AND LOWER(COALESCE(last_name, '')) = LOWER(COALESCE(p_last_name, ''));\r\n        \r\n        -- Если нашли по ФИО - обновляем email\r\n        IF v_contact_id IS NOT NULL THEN\r\n            UPDATE contacts\r\n            SET email = COALESCE(v_normalized_email, email),\r\n                phone = COALESCE(p_phone, phone),\r\n                updated_at = NOW()\r\n            WHERE id = v_contact_id;\r\n            RETURN v_contact_id;\r\n        END IF;\r\n    END IF;\r\n    \r\n    -- Если никого не нашли - создаем нового\r\n    INSERT INTO contacts (company_id, email, first_name, last_name, phone)\r\n    VALUES (p_company_id, v_normalized_email, p_first_name, p_last_name, p_phone)\r\n    RETURNING id INTO v_contact_id;\r\n    \r\n    RETURN v_contact_id;\r\nEND;\r\n$function$\n"
  },
  {
    "filename": "upsert_deal.sql",
    "content": "CREATE OR REPLACE FUNCTION public.upsert_deal(p_company_id uuid, p_contact_id uuid, p_product_name text, p_product_description text, p_price numeric, p_stage integer, p_sample_shipment_date date, p_notes text)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_deal_id UUID;\r\n    v_old_stage INTEGER;\r\n    v_stage_changed BOOLEAN := FALSE;\r\n    v_product_name TEXT;\r\nBEGIN\r\n    v_product_name := TRIM(REGEXP_REPLACE(p_product_name, '\\s+', ' ', 'g'));\r\n    IF v_product_name = '' OR v_product_name IS NULL THEN\r\n        v_product_name := 'Продукт не указан';\r\n    END IF;\r\n    \r\n    SELECT id, stage INTO v_deal_id, v_old_stage\r\n    FROM deals\r\n    WHERE company_id = p_company_id\r\n      AND LOWER(TRIM(REGEXP_REPLACE(product_name, '\\s+', ' ', 'g'))) = LOWER(v_product_name)\r\n      AND status = 'open'\r\n    LIMIT 1;\r\n    \r\n    IF v_deal_id IS NOT NULL THEN\r\n        v_stage_changed := (v_old_stage != p_stage);\r\n        \r\n        UPDATE deals\r\n        SET contact_id = COALESCE(p_contact_id, contact_id),\r\n            product_description = COALESCE(p_product_description, product_description),\r\n            price = COALESCE(p_price, price),\r\n            stage = p_stage,\r\n            sample_shipment_date = COALESCE(p_sample_shipment_date, sample_shipment_date),\r\n            notes = CASE \r\n                WHEN p_notes IS NOT NULL THEN \r\n                    COALESCE(TO_CHAR(NOW(), 'DD.MM.YYYY HH24:MI') || E'\\n' || p_notes || E'\\n---\\n' || notes, p_notes)\r\n                ELSE notes\r\n            END,\r\n            updated_at = NOW()\r\n        WHERE id = v_deal_id;\r\n    ELSE\r\n        INSERT INTO deals (\r\n            company_id, contact_id, product_name, product_description,\r\n            price, stage, sample_shipment_date, notes, status\r\n        )\r\n        VALUES (\r\n            p_company_id, p_contact_id, v_product_name, p_product_description,\r\n            p_price, p_stage, p_sample_shipment_date, p_notes, 'open'\r\n        )\r\n        RETURNING id INTO v_deal_id;\r\n        \r\n        v_stage_changed := TRUE;\r\n    END IF;\r\n    \r\n    RETURN jsonb_build_object(\r\n        'deal_id', v_deal_id,\r\n        'stage_changed', v_stage_changed,\r\n        'old_stage', v_old_stage,\r\n        'new_stage', p_stage\r\n    );\r\nEND;\r\n$function$\n"
  }
]